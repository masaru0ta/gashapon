<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>1-1 マップ表示</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=DotGothic16&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: var(--color-bg, #000);
    color: var(--color-text, #e0e0e0);
    font-family: var(--font-family, 'DotGothic16', 'Courier New', monospace);
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100vh;
    height: 100dvh;
    overflow: hidden;
  }

  .game-container {
    display: flex;
    flex-direction: column;
    width: 100%;
    max-width: var(--layout-max-width, 1200px);
    height: 100vh;
    height: 100dvh;
  }

  /* --- マップエリア --- */
  .map-area {
    flex: 1;
    min-height: 0;
    background: var(--color-map-bg, #000);
    position: relative;
    overflow: hidden;
    border-bottom: 2px solid var(--color-map-border, #444);
  }
  #mapCanvas {
    display: block;
    image-rendering: pixelated;
    cursor: grab;
    width: 100%;
    height: 100%;
    touch-action: none;
  }
  #mapCanvas:active { cursor: grabbing; }

  /* --- 地形情報オーバーレイ --- */
  .terrain-overlay {
    position: absolute;
    bottom: var(--overlay-bottom, 4px);
    left: var(--overlay-left, 4px);
    background: var(--color-overlay-bg, rgba(0, 0, 0, 0.7));
    padding: var(--overlay-padding, 2px 6px);
    border-radius: var(--overlay-border-radius, 2px);
    font-size: var(--font-overlay, 10px);
    color: var(--color-overlay-text, #ccc);
    pointer-events: none;
    display: none;
  }
  .terrain-overlay.visible { display: block; }

  /* --- 下部ステータスバー --- */
  .status-bar {
    max-height: var(--status-max-height, 180px);
    background: var(--color-status-bg, #1a1a2e);
    display: flex;
    align-items: stretch;
    border-top: 2px solid var(--color-status-border-top, #555);
    flex-shrink: 1;
    overflow: hidden;
    padding: var(--status-padding, clamp(2px, 0.5vh, 4px) 0);
  }

  .player-info {
    flex: 1;
    padding: var(--player-info-padding, clamp(2px, 1vh, 8px) clamp(8px, 2vw, 16px));
    display: flex;
    flex-direction: column;
    justify-content: center;
    gap: var(--player-info-gap, clamp(0px, 0.3vh, 2px));
    min-width: 0;
  }
  .player-info.left { text-align: left; }
  .player-info.right { text-align: right; }

  .resource-line {
    font-size: var(--font-resource, clamp(12px, 2.3vh, 18px));
    line-height: 1.2;
    white-space: nowrap;
    color: var(--color-resource, #44cc44);
  }
  .stat-line {
    font-size: var(--font-stat, clamp(10px, 2vh, 16px));
    line-height: 1.2;
    display: flex;
    gap: var(--stat-line-gap, 8px);
  }
  .player-info.right .stat-line { justify-content: flex-end; }
  .stat-item { white-space: nowrap; }
  .stat-item .icon-gp { color: var(--color-icon-gp, #4488ff); }
  .stat-item .icon-gb { color: var(--color-icon-gb, #ff4488); }
  .stat-item .icon-t { color: var(--color-icon-t, #44cc44); }

  .unit-count {
    font-size: var(--font-unit-count, clamp(20px, 5.5vh, 42px));
    font-weight: bold;
    line-height: 1;
  }
  .player-info.left .unit-count { color: var(--color-p1-unit-count, #4488ff); }
  .player-info.right .unit-count { color: var(--color-p2-unit-count, #ff4488); }

  /* 中央: ミニマップ + ターン */
  .center-panel {
    width: var(--center-panel-width, clamp(120px, 25vw, 280px));
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: var(--center-panel-gap, clamp(1px, 0.5vh, 4px));
  }
  .turn-display {
    display: flex;
    align-items: center;
    gap: var(--turn-display-gap, 12px);
  }
  .turn-number {
    font-size: var(--font-turn-number, clamp(16px, 3.5vh, 28px));
    font-weight: bold;
    color: var(--color-turn-number, #44cc44);
    background: var(--color-turn-number-bg, #224422);
    padding: var(--turn-number-padding, 0 4px);
    border-radius: var(--turn-number-border-radius, 2px);
  }
  .turn-phase {
    font-size: var(--font-turn-phase, clamp(14px, 3vh, 24px));
  }
  .turn-phase.p1 { color: var(--color-player1-primary, #4488ff); }
  .turn-phase.p2 { color: var(--color-player2-primary, #ff4488); }

  /* --- ターン終了バー (7-1) --- */
  .end-turn-bar {
    flex-shrink: 0;
    background: var(--color-status-bg, #1a1a2e);
    padding: var(--end-turn-bar-padding, clamp(2px, 0.5vh, 4px) clamp(8px, 2vw, 16px));
  }
  .end-turn-button {
    background: var(--color-turn-end-bg, #335533);
    color: var(--color-turn-end-text, #44cc44);
    border: 1px solid var(--color-turn-end-border, #44cc44);
    font-family: var(--font-family, 'DotGothic16', 'Courier New', monospace);
    font-size: var(--font-turn-end, clamp(10px, 2vh, 14px));
    padding: var(--turn-end-button-padding, clamp(4px, 0.8vh, 8px) clamp(8px, 2vw, 12px));
    border-radius: var(--turn-end-button-border-radius, 3px);
    cursor: pointer;
    width: var(--turn-end-button-width, 100%);
    text-align: center;
  }
  .end-turn-button:hover {
    background: var(--color-turn-end-hover-bg, #446644);
  }
  .end-turn-button:disabled {
    opacity: var(--turn-end-disabled-opacity, 0.4);
    cursor: not-allowed;
  }
  #miniMapCanvas {
    border: 1px solid var(--color-minimap-border, #888);
    background: var(--color-minimap-bg, #222);
    image-rendering: pixelated;
    cursor: pointer;
    max-width: 100%;
    max-height: var(--minimap-max-height, clamp(60px, 15vh, 120px));
    touch-action: none;
  }
</style>
</head>
<body>

<div class="game-container" data-testid="game-container">
  <div class="map-area" data-testid="map-area">
    <canvas id="mapCanvas" data-testid="map-canvas"></canvas>
    <div class="terrain-overlay" id="terrainOverlay" data-testid="terrain-overlay">
      <span id="coordText" data-testid="coord-text">(0,0)</span> | <span id="terrainName" data-testid="terrain-name">-</span><span id="unitInfo" data-testid="unit-info"></span>
    </div>
  </div>

  <div class="status-bar" data-testid="status-bar">
    <div class="player-info left" data-testid="p1-info">
      <div class="resource-line" data-testid="p1-ig">IG......550</div>
      <div class="resource-line" data-testid="p1-ct">CT....14300</div>
      <div class="stat-line">
        <span class="stat-item" data-testid="p1-gp"><span class="icon-gp">GP</span>3</span>
        <span class="stat-item" data-testid="p1-production"><span class="icon-t">T</span>0</span>
      </div>
      <div class="stat-line">
        <span class="stat-item" data-testid="p1-gb"><span class="icon-gb">GB</span>2</span>
      </div>
      <div class="unit-count" data-testid="p1-unit-count">21</div>
    </div>

    <div class="center-panel">
      <div class="turn-display">
        <span class="turn-number" data-testid="turn-number">1</span>
        <span class="turn-phase p1" data-testid="turn-phase">P1</span>
      </div>
      <canvas id="miniMapCanvas" data-testid="mini-map-canvas" width="200" height="120"></canvas>
    </div>

    <div class="player-info right" data-testid="p2-info">
      <div class="resource-line" data-testid="p2-ig">IG......1350</div>
      <div class="resource-line" data-testid="p2-ct">CT......2750</div>
      <div class="stat-line">
        <span class="stat-item" data-testid="p2-gp"><span class="icon-gp">GP</span>3</span>
        <span class="stat-item" data-testid="p2-production"><span class="icon-t">T</span>0</span>
      </div>
      <div class="stat-line">
        <span class="stat-item" data-testid="p2-gb"><span class="icon-gb">GB</span>1</span>
      </div>
      <div class="unit-count" data-testid="p2-unit-count">09</div>
    </div>
  </div>

  <div class="end-turn-bar" data-testid="end-turn-bar">
    <button class="end-turn-button" id="end-turn-button" data-testid="end-turn-button"></button>
  </div>
</div>

<script>
// configファイルのベースパス（ページのディレクトリを基準に解決）
const CONFIG_BASE = (() => {
  let path = location.pathname;
  // 拡張子なし（cleanUrlsリダイレクト等）の場合はディレクトリとして扱う
  if (!path.endsWith('/') && !path.includes('.')) path += '/';
  const dir = path.endsWith('/') ? path : path.substring(0, path.lastIndexOf('/') + 1);
  return dir + 'config/';
})();

// --- 設定値（JSONから読み込み、フォールバック用にデフォルト値を保持） ---
let TERRAINS = [];
let TERRAIN_MAP = new Map();
let COST_ALL = -1;
let COST_BLOCKED = -2;
let MOVEMENT_COST_TABLE = {};
let TILE_SIZE = 16;
let MIN_SCALE = 1;
let MAX_SCALE = 4;
let SCROLL_SPEED = 32;
let SAMPLE_MAP = [];
let MAP_COLS = 25;
let MAP_ROWS = 25;

// --- UI描画設定（JSONから読み込み） ---
let DRAW = {
  hover: { fill: 'rgba(255, 255, 255, 0.15)', stroke: 'rgba(255, 255, 255, 0.5)', lineWidth: 2 },
  selection: { stroke: '#ffcc00', fill: '#ffcc00', lineWidth: 3, cornerRatio: 0.2, minCornerSize: 4 },
  unitSelection: { fill: 'rgba(255, 255, 255, 0.1)', stroke: '#ffffff', lineWidth: 2 },
  moveRange: { fill: 'rgba(0, 160, 255, 0.25)', stroke: 'rgba(0, 160, 255, 0.6)', lineWidth: 1 },
  attackRange: { fill: 'rgba(255, 64, 64, 0.25)', stroke: 'rgba(255, 64, 64, 0.6)', lineWidth: 1 },
  miniMapViewport: { stroke: '#ff8800', lineWidth: 2 },
  unitFallback: { stroke: '#ffffff', strokeWidth: 2, text: '#ffffff' },
  player1Color: '#4488ff',
  player2Color: '#ff4488',
};

// --- マップ表示設定（JSONから読み込み） ---
let ZOOM_WHEEL_IN = 1.1;
let ZOOM_WHEEL_OUT = 0.9;
let DRAG_THRESHOLD_MOUSE = 2;
let DRAG_THRESHOLD_TOUCH = 3;
let BLINK_INTERVAL = 500;
let TILE_ASSET_BASE = '../assets/terrain/';
let UNIT_ASSET_BASE = '../assets/units/';
let UNIT_DRAW_RATIO_W = 0.75;
let UNIT_DRAW_RATIO_H = 1.0;
let UNIT_FALLBACK_RADIUS = 0.35;
let UNIT_MOVED_OPACITY = 0.4;

// --- サンプルユニットデータ (2-1) ---
let units = [];
let selectedUnitId = -1;
let movementRange = {};
let currentPlayer = 1;

// --- ターン管理状態 (7-1) ---
let turnNumber = 1;
let players = {};
let endTurnButtonLabel = 'ターンおわり';

// --- アニメーション状態 (2-1) ---
let isAnimating = false;
let animatingUnitId = -1;
let animationPath = [];
let animationStep = 0;
let animationSpeed = 50;
let animationTimerId = null;
let animationResolve = null;

// --- 状態 ---
let scale = 2;
let scrollX = 0;
let scrollY = 0;
let hoverCol = -1;
let hoverRow = -1;
let selectedCol = -1;
let selectedRow = -1;
let blinkVisible = true;
let canvasW = 512;
let canvasH = 400;

function ts() { return TILE_SIZE * scale; }
function mapOffsetX() { return Math.max(0, (canvasW - MAP_COLS * ts()) / 2); }
function mapOffsetY() { return Math.max(0, (canvasH - MAP_ROWS * ts()) / 2); }
function maxScrollX() { return Math.max(0, MAP_COLS * ts() - canvasW); }
function maxScrollY() { return Math.max(0, MAP_ROWS * ts() - canvasH); }

function clampScroll() {
  scrollX = Math.max(0, Math.min(maxScrollX(), scrollX));
  scrollY = Math.max(0, Math.min(maxScrollY(), scrollY));
}

function refreshView() {
  clampScroll();
  drawMap();
  drawMiniMap();
  updateGameState();
}

function canvasToMap(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const cx = (clientX - rect.left) * (canvasW / rect.width);
  const cy = (clientY - rect.top) * (canvasH / rect.height);
  return {
    col: Math.floor((cx - mapOffsetX() + scrollX) / ts()),
    row: Math.floor((cy - mapOffsetY() + scrollY) / ts()),
  };
}

function zoomAt(clientX, clientY, newScale) {
  const rect = canvas.getBoundingClientRect();
  const cx = (clientX - rect.left) * (canvasW / rect.width);
  const cy = (clientY - rect.top) * (canvasH / rect.height);
  const mapX = (cx - mapOffsetX() + scrollX) / ts();
  const mapY = (cy - mapOffsetY() + scrollY) / ts();
  scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));
  scrollX = mapX * ts() - cx + mapOffsetX();
  scrollY = mapY * ts() - cy + mapOffsetY();
  refreshView();
}

// --- gameState 公開（仕様書 3.4.3） ---
function updateGameState() {
  window.gameState = {
    scale,
    scrollX,
    scrollY,
    mapOffsetX: mapOffsetX(),
    mapOffsetY: mapOffsetY(),
    selectedCol,
    selectedRow,
    hoverCol,
    hoverRow,
    MAP_COLS,
    MAP_ROWS,
    TILE_SIZE,
    MIN_SCALE,
    MAX_SCALE,
    SCROLL_SPEED,
    // 2-1 追加
    units,
    selectedUnitId,
    movementRange,
    currentPlayer,
    MOVEMENT_COST_TABLE,
    COST_ALL,
    COST_BLOCKED,
    // アニメーション状態
    isAnimating,
    animatingUnitId,
    animationPath: animationPath.map(p => ({col: p.col, row: p.row})),
    // 7-1 ターン管理
    turnNumber,
    players,
  };
}

// --- JSON設定読み込み ---
async function loadConfig() {
  try {
    const [terrainsData, mapData, settingsData, themeData] = await Promise.all([
      fetch(CONFIG_BASE + 'terrains.json').then(r => r.json()),
      fetch(CONFIG_BASE + 'map_sample.json').then(r => r.json()),
      fetch(CONFIG_BASE + 'map_settings.json').then(r => r.json()),
      fetch(CONFIG_BASE + 'ui_theme.json').then(r => r.json()),
    ]);

    // 地形定義
    TERRAINS = terrainsData.terrains;
    TERRAIN_MAP = new Map(TERRAINS.map(t => [t.id, t]));
    COST_ALL = terrainsData.movementCost.specialCosts.COST_ALL;
    COST_BLOCKED = terrainsData.movementCost.specialCosts.COST_BLOCKED;
    const rawTable = terrainsData.movementCost.table;
    MOVEMENT_COST_TABLE = {};
    for (const key of Object.keys(rawTable)) {
      MOVEMENT_COST_TABLE[Number(key)] = rawTable[key];
    }

    // マップデータ
    SAMPLE_MAP = mapData.map;
    MAP_COLS = SAMPLE_MAP[0].length;
    MAP_ROWS = SAMPLE_MAP.length;
    units = mapData.units.map(u => ({...u, spriteImage: null}));

    // プレイヤーデータ (7-1)
    if (mapData.players) {
      players = {};
      for (const key of Object.keys(mapData.players)) {
        players[Number(key)] = {...mapData.players[key]};
      }
    }

    // マップ表示設定
    TILE_SIZE = settingsData.tile.size;
    TILE_ASSET_BASE = settingsData.tile.assetBasePath;
    MIN_SCALE = settingsData.zoom.min;
    MAX_SCALE = settingsData.zoom.max;
    scale = settingsData.zoom.initial;
    ZOOM_WHEEL_IN = settingsData.zoom.wheelFactor.zoomIn;
    ZOOM_WHEEL_OUT = settingsData.zoom.wheelFactor.zoomOut;
    SCROLL_SPEED = settingsData.scroll.keyboardSpeed;
    DRAG_THRESHOLD_MOUSE = settingsData.scroll.dragThreshold.mouse;
    DRAG_THRESHOLD_TOUCH = settingsData.scroll.dragThreshold.touch;
    animationSpeed = settingsData.animation.moveSpeed;
    BLINK_INTERVAL = settingsData.animation.blinkInterval;
    UNIT_ASSET_BASE = settingsData.unitSprite.assetBasePath;
    UNIT_DRAW_RATIO_W = settingsData.unitSprite.drawRatio.width;
    UNIT_DRAW_RATIO_H = settingsData.unitSprite.drawRatio.height;
    UNIT_FALLBACK_RADIUS = settingsData.unitSprite.fallbackRadius;
    UNIT_MOVED_OPACITY = settingsData.unitSprite.movedOpacity;

    // ミニマップサイズ
    miniCanvas.width = settingsData.miniMap.width;
    miniCanvas.height = settingsData.miniMap.height;

    // UI描画設定
    const hl = themeData.colors.highlight;
    DRAW.hover = hl.hover;
    DRAW.selection = hl.selection;
    DRAW.unitSelection = hl.unitSelection;
    DRAW.moveRange = hl.moveRange;
    DRAW.attackRange = hl.attackRange;
    DRAW.miniMapViewport = themeData.colors.miniMap.viewport;
    DRAW.unitFallback = themeData.colors.unitFallback;
    DRAW.player1Color = themeData.colors.player1.primary;
    DRAW.player2Color = themeData.colors.player2.primary;

    // ターン終了ボタンラベル (7-1)
    if (themeData.labels && themeData.labels.endTurnButton) {
      endTurnButtonLabel = themeData.labels.endTurnButton;
    }

    // CSSカスタムプロパティを適用
    applyTheme(themeData);
  } catch (e) {
    console.warn('Config load failed, using defaults:', e);
  }
}

function applyTheme(theme) {
  const s = document.documentElement.style;
  // 色
  s.setProperty('--color-bg', theme.colors.background);
  s.setProperty('--color-text', theme.colors.text);
  s.setProperty('--color-map-bg', theme.colors.mapArea.background);
  s.setProperty('--color-map-border', theme.colors.mapArea.border);
  s.setProperty('--color-status-bg', theme.colors.statusBar.background);
  s.setProperty('--color-status-border-top', theme.colors.statusBar.borderTop);
  s.setProperty('--color-p1-unit-count', theme.colors.player1.unitCount);
  s.setProperty('--color-p2-unit-count', theme.colors.player2.unitCount);
  s.setProperty('--color-resource', theme.colors.resource);
  s.setProperty('--color-icon-gp', theme.colors.statIcons.gp);
  s.setProperty('--color-icon-gb', theme.colors.statIcons.gb);
  s.setProperty('--color-icon-t', theme.colors.statIcons.t);
  s.setProperty('--color-turn-number', theme.colors.turn.number);
  s.setProperty('--color-turn-number-bg', theme.colors.turn.numberBg);
  s.setProperty('--color-turn-phase', theme.colors.turn.phase);
  s.setProperty('--color-overlay-bg', theme.colors.overlay.background);
  s.setProperty('--color-overlay-text', theme.colors.overlay.text);
  s.setProperty('--color-minimap-border', theme.colors.miniMap.border);
  s.setProperty('--color-minimap-bg', theme.colors.miniMap.background);
  // フォント
  s.setProperty('--font-family', theme.fonts.family);
  s.setProperty('--font-unit-count', theme.fonts.unitCount);
  s.setProperty('--font-turn-number', theme.fonts.turnNumber);
  s.setProperty('--font-turn-phase', theme.fonts.turnPhase);
  s.setProperty('--font-resource', theme.fonts.resource);
  s.setProperty('--font-stat', theme.fonts.stat);
  s.setProperty('--font-overlay', theme.fonts.overlay);
  // レイアウト
  s.setProperty('--layout-max-width', theme.layout.maxWidth + 'px');
  s.setProperty('--status-max-height', theme.layout.statusBar.maxHeight + 'px');
  s.setProperty('--status-padding', theme.layout.statusBar.padding);
  s.setProperty('--player-info-padding', theme.layout.playerInfo.padding);
  s.setProperty('--player-info-gap', theme.layout.playerInfo.gap);
  s.setProperty('--center-panel-width', theme.layout.centerPanel.width);
  s.setProperty('--center-panel-gap', theme.layout.centerPanel.gap);
  s.setProperty('--turn-display-gap', theme.layout.turnDisplay.gap);
  s.setProperty('--stat-line-gap', theme.layout.statLine.gap);
  s.setProperty('--overlay-padding', theme.layout.overlay.padding);
  s.setProperty('--overlay-border-radius', theme.layout.overlay.borderRadius);
  s.setProperty('--overlay-bottom', theme.layout.overlay.bottom);
  s.setProperty('--overlay-left', theme.layout.overlay.left);
  s.setProperty('--turn-number-padding', theme.layout.turnNumber.padding);
  s.setProperty('--turn-number-border-radius', theme.layout.turnNumber.borderRadius);
  s.setProperty('--minimap-max-height', theme.layout.miniMap.maxHeight);
  // 7-1 ターン終了ボタン
  if (theme.colors.turnEnd) {
    s.setProperty('--color-turn-end-bg', theme.colors.turnEnd.background);
    s.setProperty('--color-turn-end-text', theme.colors.turnEnd.text);
    s.setProperty('--color-turn-end-border', theme.colors.turnEnd.border);
    s.setProperty('--color-turn-end-hover-bg', theme.colors.turnEnd.hoverBackground);
    s.setProperty('--turn-end-disabled-opacity', String(theme.colors.turnEnd.disabledOpacity));
  }
  if (theme.colors.player1) s.setProperty('--color-player1-primary', theme.colors.player1.primary);
  if (theme.colors.player2) s.setProperty('--color-player2-primary', theme.colors.player2.primary);
  if (theme.fonts.turnEnd) s.setProperty('--font-turn-end', theme.fonts.turnEnd);
  if (theme.layout.turnEndButton) {
    s.setProperty('--turn-end-button-padding', theme.layout.turnEndButton.padding);
    s.setProperty('--turn-end-button-border-radius', theme.layout.turnEndButton.borderRadius);
    s.setProperty('--turn-end-button-width', theme.layout.turnEndButton.width);
  }
  if (theme.layout.endTurnBar) {
    s.setProperty('--end-turn-bar-padding', theme.layout.endTurnBar.padding);
  }
}

// --- タイル画像読み込み ---
const tileImages = {};
let loadedCount = 0;

function loadTileImages(callback) {
  if (TERRAINS.length === 0) { callback(); return; }
  loadedCount = 0;
  TERRAINS.forEach(t => {
    const img = new Image();
    img.onload = img.onerror = () => {
      if (!img.naturalWidth) tileImages[t.id] = null;
      if (++loadedCount === TERRAINS.length) callback();
    };
    img.src = TILE_ASSET_BASE + t.file;
    tileImages[t.id] = img;
  });
}

// --- ユニットスプライト読み込み (2-1) ---
function loadUnitSprites(callback) {
  let loaded = 0;
  const total = units.length;
  if (total === 0) { callback(); return; }
  units.forEach(unit => {
    const color = unit.player === 1 ? 'b' : 'r';
    const fileName = unit.name.toLowerCase() + color + 'btlf.gif';
    const img = new Image();
    img.onload = () => {
      unit.spriteImage = img;
      if (++loaded === total) callback();
    };
    img.onerror = () => {
      unit.spriteImage = null;
      if (++loaded === total) callback();
    };
    img.src = UNIT_ASSET_BASE + fileName;
  });
}

// --- メインCanvas ---
const canvas = document.getElementById('mapCanvas');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
  const mapArea = document.querySelector('.map-area');
  canvasW = mapArea.clientWidth;
  canvasH = mapArea.clientHeight;
  canvas.width = canvasW;
  canvas.height = canvasH;
  refreshView();
}

const DIRS = [[0,-1],[0,1],[-1,0],[1,0]];

// --- ユニットヘルパー関数 (2-1) ---
function getUnitAtPos(col, row) {
  return units.find(u => u.col === col && u.row === row) || null;
}

function calculateMovementRangeForUnit(unit) {
  const reachable = {};
  const visited = {};
  const queue = [[0, unit.col, unit.row]];

  while (queue.length > 0) {
    queue.sort((a, b) => a[0] - b[0]);
    const [cost, col, row] = queue.shift();
    const key = col + ',' + row;

    if (visited[key]) continue;
    visited[key] = true;
    reachable[key] = unit.mv - cost;

    // 敵ユニットがいるタイルからは展開しない
    const unitHere = getUnitAtPos(col, row);
    if (unitHere && unitHere.player !== currentPlayer) continue;

    for (const [dc, dr] of DIRS) {
      const nc = col + dc;
      const nr = row + dr;
      if (nc < 0 || nc >= MAP_COLS || nr < 0 || nr >= MAP_ROWS) continue;
      const nkey = nc + ',' + nr;
      if (visited[nkey]) continue;

      const terrainId = SAMPLE_MAP[nr][nc];
      const moveCost = MOVEMENT_COST_TABLE[terrainId][unit.type];

      if (moveCost === COST_BLOCKED) continue;

      if (moveCost === COST_ALL) {
        if (cost < unit.mv && !visited[nkey]) {
          reachable[nkey] = 0;
          visited[nkey] = true;
        }
        continue;
      }

      const newCost = cost + moveCost;
      if (newCost <= unit.mv) {
        queue.push([newCost, nc, nr]);
      }
    }
  }

  // 起点を除外
  delete reachable[unit.col + ',' + unit.row];

  // 自軍ユニットが占有するタイルを除外（通過は可能）
  units.forEach(u => {
    if (u.player === currentPlayer && u.id !== unit.id) {
      delete reachable[u.col + ',' + u.row];
    }
  });

  return reachable;
}

function selectUnitById(unitId) {
  const unit = units.find(u => u.id === unitId);
  if (!unit || unit.player !== currentPlayer || unit.moved) return;
  selectedUnitId = unitId;
  movementRange = calculateMovementRangeForUnit(unit);
  selectedCol = -1;
  selectedRow = -1;
  blinkVisible = true;
  refreshView();
}

function deselectUnit() {
  selectedUnitId = -1;
  movementRange = {};
  blinkVisible = true;
  refreshView();
}

// --- 経路計算（ダイクストラ + 親ポインタ） ---
function findPath(fromCol, fromRow, toCol, toRow, unit) {
  const bestCost = {};
  const parent = {};
  const queue = [[0, fromCol, fromRow]];
  const startKey = fromCol + ',' + fromRow;
  bestCost[startKey] = 0;
  parent[startKey] = null;

  while (queue.length > 0) {
    queue.sort((a, b) => a[0] - b[0]);
    const [cost, c, r] = queue.shift();
    const key = c + ',' + r;
    if (cost > (bestCost[key] !== undefined ? bestCost[key] : Infinity)) continue;
    if (c === toCol && r === toRow) break;

    const unitHere = getUnitAtPos(c, r);
    if (unitHere && unitHere.player !== currentPlayer && !(c === fromCol && r === fromRow)) continue;

    for (const [dc, dr] of DIRS) {
      const nc = c + dc;
      const nr = r + dr;
      if (nc < 0 || nc >= MAP_COLS || nr < 0 || nr >= MAP_ROWS) continue;
      const nkey = nc + ',' + nr;
      const terrainId = SAMPLE_MAP[nr][nc];
      const moveCost = MOVEMENT_COST_TABLE[terrainId][unit.type];
      if (moveCost === COST_BLOCKED) continue;
      if (moveCost === COST_ALL) {
        if (cost < unit.mv && bestCost[nkey] === undefined) {
          bestCost[nkey] = unit.mv;
          parent[nkey] = key;
        }
        continue;
      }
      const newCost = cost + moveCost;
      if (newCost <= unit.mv && newCost < (bestCost[nkey] !== undefined ? bestCost[nkey] : Infinity)) {
        bestCost[nkey] = newCost;
        parent[nkey] = key;
        queue.push([newCost, nc, nr]);
      }
    }
  }

  const destKey = toCol + ',' + toRow;
  if (parent[destKey] === undefined && destKey !== startKey) return [];
  const path = [];
  let cur = destKey;
  while (cur !== null) {
    const parts = cur.split(',');
    path.unshift({col: parseInt(parts[0]), row: parseInt(parts[1])});
    cur = parent[cur];
  }
  return path;
}

// --- 移動アニメーション（マス単位離散移動） ---
function startMoveAnimation(unit, path) {
  if (path.length <= 1 || animationSpeed === 0) return;
  isAnimating = true;
  animatingUnitId = unit.id;
  animationPath = path;
  animationStep = 0;
  updateGameState();

  let stepIndex = 0;
  function advanceStep() {
    stepIndex++;
    if (stepIndex < path.length) {
      animationStep = stepIndex;
      drawMap();
      updateGameState();
      setTimeout(advanceStep, animationSpeed);
    } else {
      isAnimating = false;
      animatingUnitId = -1;
      animationPath = [];
      animationTimerId = null;
      drawMap();
      updateGameState();
      if (animationResolve) {
        const resolve = animationResolve;
        animationResolve = null;
        resolve();
      }
    }
  }
  drawMap();
  setTimeout(advanceStep, animationSpeed);
}

function executeMove(unit, col, row, animate) {
  const enemyUnit = getUnitAtPos(col, row);
  if (enemyUnit && enemyUnit.player !== currentPlayer) {
    console.log('Battle: ' + unit.name + ' vs ' + enemyUnit.name);
  }
  const path = animate ? findPath(unit.col, unit.row, col, row, unit) : null;
  unit.col = col;
  unit.row = row;
  unit.moved = true;
  if (path && path.length > 1) startMoveAnimation(unit, path);
  deselectUnit();
}

function handleTileClick(col, row) {
  if (isAnimating) return;
  if (col < 0 || col >= MAP_COLS || row < 0 || row >= MAP_ROWS) return;

  const clickedUnit = getUnitAtPos(col, row);

  // 優先1: 自軍未移動ユニット → 選択/切替/解除
  if (clickedUnit && clickedUnit.player === currentPlayer && !clickedUnit.moved) {
    if (selectedUnitId === clickedUnit.id) {
      deselectUnit();
    } else {
      selectUnitById(clickedUnit.id);
    }
    return;
  }

  // 優先2: ユニット選択中 + 移動範囲内 → 移動実行
  if (selectedUnitId !== -1) {
    const key = col + ',' + row;
    if (movementRange[key] !== undefined) {
      const unit = units.find(u => u.id === selectedUnitId);
      if (unit) {
        executeMove(unit, col, row, true);
        return;
      }
    }
    // 範囲外 → 選択解除
    deselectUnit();
    return;
  }

  // ユニット操作なし → タイル選択（1-1互換）
  toggleSelection(col, row);
}

// --- マップ描画 ---
function drawMap() {
  if (SAMPLE_MAP.length === 0) return;
  const t = ts();
  const ox = mapOffsetX();
  const oy = mapOffsetY();
  ctx.imageSmoothingEnabled = false;
  ctx.clearRect(0, 0, canvasW, canvasH);

  const startCol = Math.max(0, Math.floor(scrollX / t));
  const startRow = Math.max(0, Math.floor(scrollY / t));
  const endCol = Math.min(MAP_COLS - 1, Math.floor((scrollX + canvasW) / t));
  const endRow = Math.min(MAP_ROWS - 1, Math.floor((scrollY + canvasH) / t));

  for (let row = startRow; row <= endRow; row++) {
    for (let col = startCol; col <= endCol; col++) {
      const id = SAMPLE_MAP[row][col];
      const x = col * t - scrollX + ox;
      const y = row * t - scrollY + oy;
      const img = tileImages[id];
      if (img && img.complete && img.naturalWidth > 0) {
        ctx.drawImage(img, x, y, t, t);
      } else {
        const terrain = TERRAIN_MAP.get(id);
        ctx.fillStyle = terrain ? terrain.color : '#ff00ff';
        ctx.fillRect(x, y, t, t);
      }
    }
  }

  // 移動範囲ハイライト (2-1)
  if (selectedUnitId !== -1) {
    for (const key of Object.keys(movementRange)) {
      const parts = key.split(',');
      const c = parseInt(parts[0]);
      const r = parseInt(parts[1]);
      if (c < startCol || c > endCol || r < startRow || r > endRow) continue;
      const rx = c * t - scrollX + ox;
      const ry = r * t - scrollY + oy;
      const enemyUnit = getUnitAtPos(c, r);
      if (enemyUnit && enemyUnit.player !== currentPlayer) {
        ctx.fillStyle = DRAW.attackRange.fill;
        ctx.fillRect(rx, ry, t, t);
        ctx.strokeStyle = DRAW.attackRange.stroke;
        ctx.lineWidth = DRAW.attackRange.lineWidth;
        ctx.strokeRect(rx + 0.5, ry + 0.5, t - 1, t - 1);
      } else {
        ctx.fillStyle = DRAW.moveRange.fill;
        ctx.fillRect(rx, ry, t, t);
        ctx.strokeStyle = DRAW.moveRange.stroke;
        ctx.lineWidth = DRAW.moveRange.lineWidth;
        ctx.strokeRect(rx + 0.5, ry + 0.5, t - 1, t - 1);
      }
    }
  }

  // ユニットスプライト描画 (2-1)
  for (const unit of units) {
    // アニメーション中はマス単位の離散位置を使用
    let drawCol = unit.col;
    let drawRow = unit.row;
    if (isAnimating && unit.id === animatingUnitId && animationPath.length > 0) {
      const pos = animationPath[animationStep];
      drawCol = pos.col;
      drawRow = pos.row;
    }
    if (drawCol < startCol - 1 || drawCol > endCol + 1 || drawRow < startRow - 1 || drawRow > endRow + 1) continue;
    const ux = drawCol * t - scrollX + ox;
    const uy = drawRow * t - scrollY + oy;
    if (unit.moved) ctx.globalAlpha = UNIT_MOVED_OPACITY;
    if (unit.spriteImage && unit.spriteImage.complete && unit.spriteImage.naturalWidth > 0) {
      const sw = t * UNIT_DRAW_RATIO_W;
      const sh = t * UNIT_DRAW_RATIO_H;
      const dx = ux + (t - sw) / 2;
      const dy = uy + (t - sh) / 2;
      ctx.drawImage(unit.spriteImage, dx, dy, sw, sh);
    } else {
      const cr = t * UNIT_FALLBACK_RADIUS;
      const ccx = ux + t / 2;
      const ccy = uy + t / 2;
      ctx.beginPath();
      ctx.arc(ccx, ccy, cr, 0, Math.PI * 2);
      ctx.fillStyle = unit.player === 1 ? DRAW.player1Color : DRAW.player2Color;
      ctx.fill();
      ctx.strokeStyle = DRAW.unitFallback.stroke;
      ctx.lineWidth = DRAW.unitFallback.strokeWidth;
      ctx.stroke();
      ctx.fillStyle = DRAW.unitFallback.text;
      ctx.font = 'bold ' + Math.max(8, t * 0.4) + 'px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(unit.name[0], ccx, ccy);
    }
    ctx.globalAlpha = 1.0;
  }

  // ホバーハイライト
  if (hoverCol >= 0 && hoverRow >= 0 && hoverCol < MAP_COLS && hoverRow < MAP_ROWS) {
    const hx = hoverCol * t - scrollX + ox;
    const hy = hoverRow * t - scrollY + oy;
    ctx.fillStyle = DRAW.hover.fill;
    ctx.fillRect(hx, hy, t, t);
    ctx.strokeStyle = DRAW.hover.stroke;
    ctx.lineWidth = DRAW.hover.lineWidth;
    ctx.strokeRect(hx + 1, hy + 1, t - 2, t - 2);
  }

  // ユニット選択ハイライト（白い点滅枠）(2-1)
  if (blinkVisible && selectedUnitId !== -1) {
    const su = units.find(u => u.id === selectedUnitId);
    if (su) {
      const sux = su.col * t - scrollX + ox;
      const suy = su.row * t - scrollY + oy;
      ctx.fillStyle = DRAW.unitSelection.fill;
      ctx.fillRect(sux, suy, t, t);
      ctx.strokeStyle = DRAW.unitSelection.stroke;
      ctx.lineWidth = DRAW.unitSelection.lineWidth;
      ctx.strokeRect(sux + 1, suy + 1, t - 2, t - 2);
    }
  }

  // タイル選択ハイライト（黄色点滅）
  if (blinkVisible && selectedCol >= 0 && selectedRow >= 0 && selectedCol < MAP_COLS && selectedRow < MAP_ROWS) {
    const sx = selectedCol * t - scrollX + ox;
    const sy = selectedRow * t - scrollY + oy;
    ctx.strokeStyle = DRAW.selection.stroke;
    ctx.lineWidth = DRAW.selection.lineWidth;
    ctx.strokeRect(sx + 1, sy + 1, t - 2, t - 2);
    const m = Math.max(DRAW.selection.minCornerSize, t * DRAW.selection.cornerRatio);
    ctx.fillStyle = DRAW.selection.fill;
    ctx.fillRect(sx, sy, m, m);
    ctx.fillRect(sx + t - m, sy, m, m);
    ctx.fillRect(sx, sy + t - m, m, m);
    ctx.fillRect(sx + t - m, sy + t - m, m, m);
  }
}

// --- ミニマップ描画 ---
const miniCanvas = document.getElementById('miniMapCanvas');
const miniCtx = miniCanvas.getContext('2d');

function drawMiniMap() {
  if (SAMPLE_MAP.length === 0) return;
  const mw = miniCanvas.width;
  const mh = miniCanvas.height;
  const tileW = mw / MAP_COLS;
  const tileH = mh / MAP_ROWS;

  miniCtx.imageSmoothingEnabled = false;
  miniCtx.clearRect(0, 0, mw, mh);

  for (let row = 0; row < MAP_ROWS; row++) {
    for (let col = 0; col < MAP_COLS; col++) {
      const terrain = TERRAIN_MAP.get(SAMPLE_MAP[row][col]);
      miniCtx.fillStyle = terrain ? terrain.color : '#ff00ff';
      miniCtx.fillRect(col * tileW, row * tileH, Math.ceil(tileW), Math.ceil(tileH));
    }
  }

  // ユニットドット描画 (2-1)
  for (const unit of units) {
    const dx = unit.col * tileW;
    const dy = unit.row * tileH;
    const dotSize = Math.max(tileW, 2);
    miniCtx.fillStyle = unit.player === 1 ? DRAW.player1Color : DRAW.player2Color;
    miniCtx.fillRect(dx, dy, dotSize, dotSize);
  }

  const t = ts();
  const vx = (scrollX / (MAP_COLS * t)) * mw;
  const vy = (scrollY / (MAP_ROWS * t)) * mh;
  const vw = (canvasW / (MAP_COLS * t)) * mw;
  const vh = (canvasH / (MAP_ROWS * t)) * mh;
  miniCtx.strokeStyle = DRAW.miniMapViewport.stroke;
  miniCtx.lineWidth = DRAW.miniMapViewport.lineWidth;
  miniCtx.strokeRect(vx, vy, Math.min(vw, mw - vx), Math.min(vh, mh - vy));
}

// --- 地形情報オーバーレイ ---
const terrainOverlay = document.getElementById('terrainOverlay');
const coordText = document.getElementById('coordText');
const terrainNameEl = document.getElementById('terrainName');
const unitInfoEl = document.getElementById('unitInfo');

function updateTerrainOverlay(col, row) {
  if (col >= 0 && col < MAP_COLS && row >= 0 && row < MAP_ROWS) {
    const terrain = TERRAIN_MAP.get(SAMPLE_MAP[row][col]);
    coordText.textContent = '(' + col + ',' + row + ')';
    terrainNameEl.textContent = terrain ? terrain.name : '不明';
    // ユニット情報 (2-1)
    const unitAtHover = getUnitAtPos(col, row);
    if (unitAtHover) {
      unitInfoEl.textContent = ' | ' + unitAtHover.name + ' [' + unitAtHover.hp + '%] MV:' + unitAtHover.mv;
    } else {
      unitInfoEl.textContent = '';
    }
    terrainOverlay.classList.add('visible');
  } else {
    unitInfoEl.textContent = '';
    terrainOverlay.classList.remove('visible');
  }
}

// --- キーボードスクロール ---
document.addEventListener('keydown', (e) => {
  switch (e.key) {
    case 'ArrowLeft':  scrollX -= SCROLL_SPEED; break;
    case 'ArrowRight': scrollX += SCROLL_SPEED; break;
    case 'ArrowUp':    scrollY -= SCROLL_SPEED; break;
    case 'ArrowDown':  scrollY += SCROLL_SPEED; break;
    case 'Escape':
      if (isAnimating) return;
      if (selectedUnitId !== -1) {
        deselectUnit();
        e.preventDefault();
      }
      return;
    default: return;
  }
  e.preventDefault();
  refreshView();
});

// --- マウスホイールズーム ---
canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  zoomAt(e.clientX, e.clientY, scale * (e.deltaY > 0 ? ZOOM_WHEEL_OUT : ZOOM_WHEEL_IN));
}, { passive: false });

// --- マウスドラッグスクロール & ミニマップ操作 ---
let isDragging = false;
let dragMoved = false;
let dragStartX, dragStartY, dragScrollX, dragScrollY;
let miniDragging = false;

function miniMapScrollToXY(clientX, clientY) {
  const rect = miniCanvas.getBoundingClientRect();
  const t = ts();
  scrollX = ((clientX - rect.left) / rect.width) * MAP_COLS * t - canvasW / 2;
  scrollY = ((clientY - rect.top) / rect.height) * MAP_ROWS * t - canvasH / 2;
  refreshView();
}

canvas.addEventListener('mousedown', (e) => {
  isDragging = true;
  dragMoved = false;
  dragStartX = e.clientX;
  dragStartY = e.clientY;
  dragScrollX = scrollX;
  dragScrollY = scrollY;
});

miniCanvas.addEventListener('mousedown', (e) => {
  e.preventDefault();
  miniDragging = true;
  miniMapScrollToXY(e.clientX, e.clientY);
});

// --- ミニマップ タッチ操作 ---
miniCanvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  miniDragging = true;
  miniMapScrollToXY(e.touches[0].clientX, e.touches[0].clientY);
}, { passive: false });

miniCanvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (miniDragging) {
    miniMapScrollToXY(e.touches[0].clientX, e.touches[0].clientY);
  }
}, { passive: false });

miniCanvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  miniDragging = false;
}, { passive: false });

window.addEventListener('mousemove', (e) => {
  if (miniDragging) {
    miniMapScrollToXY(e.clientX, e.clientY);
    return;
  }
  if (isDragging) {
    const rect = canvas.getBoundingClientRect();
    const dx = (dragStartX - e.clientX) * (canvasW / rect.width);
    const dy = (dragStartY - e.clientY) * (canvasH / rect.height);
    if (Math.abs(dx) > DRAG_THRESHOLD_MOUSE || Math.abs(dy) > DRAG_THRESHOLD_MOUSE) dragMoved = true;
    scrollX = dragScrollX + dx;
    scrollY = dragScrollY + dy;
    refreshView();
    return;
  }
  // Canvas領域内のみホバー処理（Canvas外は mouseleave で処理）
  const rect = canvas.getBoundingClientRect();
  const inCanvas = e.clientX >= rect.left && e.clientX <= rect.right
                && e.clientY >= rect.top && e.clientY <= rect.bottom;
  if (inCanvas) {
    const { col, row } = canvasToMap(e.clientX, e.clientY);
    hoverCol = (col >= 0 && col < MAP_COLS && row >= 0 && row < MAP_ROWS) ? col : -1;
    hoverRow = (hoverCol >= 0) ? row : -1;
    updateTerrainOverlay(hoverCol, hoverRow);
    drawMap();
    updateGameState();
  }
});

// --- タイル選択（クリック / タップ） ---
function toggleSelection(col, row) {
  if (col < 0 || col >= MAP_COLS || row < 0 || row >= MAP_ROWS) return;
  if (selectedCol === col && selectedRow === row) {
    selectedCol = -1; selectedRow = -1;
  } else {
    selectedCol = col; selectedRow = row;
  }
  blinkVisible = true;
  drawMap();
  updateGameState();
}

window.addEventListener('mouseup', (e) => {
  if (isDragging && !dragMoved) {
    const { col, row } = canvasToMap(e.clientX, e.clientY);
    handleTileClick(col, row);
  }
  isDragging = false;
  miniDragging = false;
});

canvas.addEventListener('mouseleave', () => {
  hoverCol = -1; hoverRow = -1;
  updateTerrainOverlay(-1, -1);
  drawMap();
  updateGameState();
});

// --- タッチ操作 ---
let touchMode = 'none';
let touchStartX, touchStartY, touchScrollX, touchScrollY;
let touchMoved = false;
let pinchStartDist, pinchStartScale;

function getTouchDist(touches) {
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  if (e.touches.length === 2) {
    touchMode = 'pinch';
    pinchStartDist = getTouchDist(e.touches);
    pinchStartScale = scale;
    touchScrollX = scrollX;
    touchScrollY = scrollY;
  } else if (e.touches.length === 1) {
    touchMode = 'drag';
    touchMoved = false;
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
    touchScrollX = scrollX;
    touchScrollY = scrollY;
  }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (touchMode === 'pinch' && e.touches.length === 2) {
    const dist = getTouchDist(e.touches);
    const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
    const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
    zoomAt(midX, midY, pinchStartScale * (dist / pinchStartDist));
  } else if (touchMode === 'drag' && e.touches.length === 1) {
    const rect = canvas.getBoundingClientRect();
    const dx = (touchStartX - e.touches[0].clientX) * (canvasW / rect.width);
    const dy = (touchStartY - e.touches[0].clientY) * (canvasH / rect.height);
    if (Math.abs(dx) > DRAG_THRESHOLD_TOUCH || Math.abs(dy) > DRAG_THRESHOLD_TOUCH) touchMoved = true;
    scrollX = touchScrollX + dx;
    scrollY = touchScrollY + dy;
    refreshView();
  }
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  if (touchMode === 'drag' && !touchMoved) {
    const { col, row } = canvasToMap(touchStartX, touchStartY);
    handleTileClick(col, row);
  }
  if (e.touches.length === 0) {
    touchMode = 'none';
  } else if (e.touches.length === 1) {
    touchMode = 'drag';
    touchMoved = false;
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
    touchScrollX = scrollX;
    touchScrollY = scrollY;
  }
}, { passive: false });

// --- 選択カーソル点滅 ---
setInterval(() => {
  if ((selectedCol >= 0 && selectedRow >= 0) || selectedUnitId !== -1) {
    blinkVisible = !blinkVisible;
    drawMap();
  }
}, BLINK_INTERVAL);

// --- ターン管理 (7-1) ---
// コールバックスタブ（将来の仕様で実装）
function onTurnStart(tn) { /* 6-1 回復, 5-1 生産完了, 1-2 CP収入 */ }
function onTurnEnd(tn) { /* 7-2 勝利条件 */ }
function onPhaseStart(pn) { /* プレイヤー固有の開始処理 */ }

// ステータスバー更新
function updatePlayerInfo(playerNum) {
  const p = players[playerNum];
  if (!p) return;
  const prefix = 'p' + playerNum;
  const el = (id) => document.querySelector('[data-testid="' + prefix + '-' + id + '"]');
  const igEl = el('ig');
  const ctEl = el('ct');
  const gpEl = el('gp');
  const gbEl = el('gb');
  const prodEl = el('production');
  const ucEl = el('unit-count');
  if (igEl) igEl.textContent = 'IG......' + p.ig;
  if (ctEl) ctEl.textContent = 'CT....' + p.ct;
  if (gpEl) gpEl.innerHTML = '<span class="icon-gp">GP</span>' + p.gp;
  if (gbEl) gbEl.innerHTML = '<span class="icon-gb">GB</span>' + p.gb;
  if (prodEl) prodEl.innerHTML = '<span class="icon-t">T</span>' + p.production;
  if (ucEl) {
    const count = units.filter(u => u.player === playerNum).length;
    ucEl.textContent = String(count).padStart(2, '0');
  }
}

function updateStatusBar() {
  const turnNumberEl = document.querySelector('[data-testid="turn-number"]');
  const turnPhaseEl = document.querySelector('[data-testid="turn-phase"]');
  if (turnNumberEl) turnNumberEl.textContent = turnNumber;
  if (turnPhaseEl) {
    turnPhaseEl.textContent = currentPlayer === 1 ? 'P1' : 'P2';
    turnPhaseEl.className = 'turn-phase ' + (currentPlayer === 1 ? 'p1' : 'p2');
  }
  updatePlayerInfo(1);
  updatePlayerInfo(2);
}

// ターン終了処理
function doEndTurn() {
  if (isAnimating) return;
  // ユニット選択中の場合は解除
  if (selectedUnitId !== -1) deselectUnit();
  if (selectedCol !== -1) { selectedCol = -1; selectedRow = -1; }

  if (currentPlayer === 1) {
    currentPlayer = 2;
    // P2の全ユニットのmovedリセット
    units.forEach(u => { if (u.player === 2) u.moved = false; });
    onPhaseStart(2);
  } else {
    onTurnEnd(turnNumber);
    turnNumber++;
    currentPlayer = 1;
    // P1の全ユニットのmovedリセット
    units.forEach(u => { if (u.player === 1) u.moved = false; });
    onTurnStart(turnNumber);
    onPhaseStart(1);
  }
  updateStatusBar();
  updateGameState();
}

// ターン終了ボタンのイベント設定
const endTurnButtonEl = document.getElementById('end-turn-button');
if (endTurnButtonEl) {
  endTurnButtonEl.addEventListener('click', doEndTurn);
}

// --- グローバルテスト関数 (2-1) ---
window.resetTurn = function() {
  units.forEach(u => { u.moved = false; });
  turnNumber = 1;
  currentPlayer = 1;
  updateStatusBar();
  refreshView();
};

window.selectUnit = function(unitId) {
  selectUnitById(unitId);
};

window.moveUnit = function(unitId, col, row) {
  const unit = units.find(u => u.id === unitId);
  if (!unit || selectedUnitId !== unitId) return false;
  const key = col + ',' + row;
  if (movementRange[key] === undefined) return false;
  executeMove(unit, col, row, false);
  return true;
};

window.getUnitAt = function(col, row) {
  return getUnitAtPos(col, row);
};

window.calculateMovementRange = function(unitId) {
  const unit = units.find(u => u.id === unitId);
  if (!unit) return {};
  return calculateMovementRangeForUnit(unit);
};

window.endTurn = function() {
  doEndTurn();
};

window.getTurnInfo = function() {
  return {
    turnNumber: turnNumber,
    currentPlayer: currentPlayer,
    phase: currentPlayer === 1 ? 'P1' : 'P2',
  };
};

window._SAMPLE_MAP = null; // loadConfig完了後に設定

window.setAnimationSpeed = function(ms) {
  animationSpeed = ms;
};

window.waitForAnimation = function() {
  if (!isAnimating) return Promise.resolve();
  return new Promise(function(resolve) {
    animationResolve = resolve;
  });
};

window.getAnimatingUnitDrawPos = function() {
  if (!isAnimating || animationPath.length === 0) return null;
  const pos = animationPath[animationStep];
  return { col: pos.col, row: pos.row };
};

// --- 初期化 ---
window.addEventListener('resize', resizeCanvas);
loadConfig().then(() => {
  window._SAMPLE_MAP = SAMPLE_MAP;
  // ターン終了ボタンのラベル設定 (7-1)
  const btnEl = document.getElementById('end-turn-button');
  if (btnEl) btnEl.textContent = endTurnButtonLabel;
  loadTileImages(() => {
    loadUnitSprites(() => {
      resizeCanvas();
      updateStatusBar();
      onTurnStart(1);
      onPhaseStart(1);
      updateGameState();
    });
  });
});
</script>
</body>
</html>
